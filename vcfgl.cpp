
/*
 *
 * VCF parser
 *
 *
 *
 * [[ MSPRIME SIMULATED VCF INPUT ]]
 * generated by tskit.write_vcf()
 *
 *
 * ** [POSITIONS]
 * Positions are 0-based
 * in contrast to regular vcf specs=1-based
 *
 * ** [ALLELES]
 * * REF(=ANC)=0
 * Reference allele is the same as ancestral allele
 * Encoded as 0
 * * ALT=1
 * Only one ALT allele is present
 * Encoded as 1
 * 
 *
 * [GL order in VCF format]
 *
 * for P=ploidy and N=number of alternate alleles;
 * for a_p in 0:N; for a_p-1 in 0:a_p; print(a1,a2);
 *
 * For P=2 N=3
 *
 * 0,1,2,3
 * A,C,G,T
 * 00,01,11,02,12,22,03,13,23,33
 * AA,AC,CC,AG,CG,GG,AT,CT,GT,TT
 *
 *
 * ** GLF
 * A, C, G, T
 *
 */

#include <stdio.h>
#include <htslib/vcf.h>
#include <htslib/vcfutils.h>

#include <inttypes.h>
#include <math.h>
#include <time.h>

#include "random_generator.h"
#include "estimator.h"
#include "io.h"

#include "version.h"

const int vcf_gl_order_idx[10]={0,1,4,2,5,7,3,6,8,9};
int a_ad;


FILE *getFILE(const char*fname,const char* mode){
	FILE *fp;
	if(NULL==(fp=fopen(fname,mode))){
		fprintf(stderr,"[%s:%s()]\t->Error opening FILE handle for file:%s exiting\n",__FILE__,__FUNCTION__,fname);
		exit(0);
	}
	return fp;
}



FILE *openFile(const char* a,const char* b){
	char *c = (char*)malloc(strlen(a)+strlen(b)+1);
	strcpy(c,a);
	strcat(c,b);
	// fprintf(stderr,"\t-> Dumping file: %s\n",c);
	FILE *fp = getFILE(c,"w");
	free(c);
	return fp;
}

int pick_base(double errate, int inbase){
	int outbase;
	if (drand48()<errate){
		while ((outbase=(floor(4*drand48()))) == inbase);
		return outbase;
	}
	else{
	  if (inbase == 0){
	    // add count for A allele if inbase is A allele (currently assuming no error rate)
	    a_ad+=1;
	  }
	  return inbase;
	}
}


char *get_time(){
	time_t current_time;
	struct tm *local_time; 
	current_time=time(NULL);
	local_time=localtime(&current_time);
	return(asctime(local_time));
}

int32_t *gt_arr=NULL;
int32_t *dp_vals=NULL;
float *gl_vals=NULL;
// reference allele count tally
int32_t *ad_vals=NULL;

int setblank(bcf1_t *blk,bcf1_t *unmod,bcf_hdr_t *hdr){

	int32_t ngt_arr=0;
	int ngt=bcf_get_genotypes(hdr, blk, &gt_arr, &ngt_arr);
	if ( ngt<=0 ){
		fprintf(stderr,"\nGT not present\n");
	}

	int32_t *tmpia = gt_arr;
	for(int i=0; i<bcf_hdr_nsamples(hdr);i++){
		tmpia[2*i+0] = bcf_gt_phased(0);
		tmpia[2*i+1] = bcf_gt_phased(0);
	}
	bcf_update_genotypes(hdr, blk, tmpia, bcf_hdr_nsamples(hdr)*2); 

	return 0;
}


int setval(bcf_hdr_t *out_hdr,bcf1_t *out_bcf,int nSamples,double errate,double mps_depth, double* mps_depths){

	if(gl_vals==NULL){
		gl_vals  =   (float*)malloc(10*nSamples*sizeof(float));
		dp_vals  =   (int32_t*)malloc(10*nSamples*sizeof(int32_t));
		// copying the format of dp_vals above
		// but not sure why it's 10 * nSamples, since each sample only has 1 dp
		ad_vals  =   (int32_t*)malloc(10*nSamples*sizeof(int32_t));
	}
	int n_sim_reads;  
	int32_t ngt_arr=0;
	int ngt=bcf_get_genotypes(out_hdr, out_bcf, &gt_arr, &ngt_arr);
	if ( ngt<=0 ){
		fprintf(stderr,"\nGT not present\n");
	}

	int gt_ploidy=ngt/nSamples;


	for (int sample_i=0; sample_i<nSamples; sample_i++) {


		if(mps_depths!=NULL){
			n_sim_reads=Poisson(mps_depths[sample_i]);
		}else{
			n_sim_reads=Poisson(mps_depth);
		}

		if(n_sim_reads==0){

			for(int j=0;j<10;j++){
				bcf_float_set_missing(gl_vals[sample_i*10+j]);
			}
			dp_vals[sample_i]=0;

		}else{

			// fprintf(stderr,"\nn_sim_reads: %d\n",n_sim_reads);
			int32_t *ptr = gt_arr + sample_i*gt_ploidy;

			if (gt_ploidy!=2){
				fprintf(stderr,"ERROR:\n\nploidy: %d not supported\n",gt_ploidy);
				return 1;
			}

			int bin_gts[2] = {0,0};

			double like[10]={-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0};

			//binary input genotypes from simulated input
			for (int i=0; i<gt_ploidy;i++){
				bin_gts[i]= bcf_gt_allele(ptr[i]);
				// use bit shifting to check if bin_gt[n] is 0 or 1
				if( (bin_gts[i] >> 1) != 0){
					fprintf(stderr,"ERROR:\n\nbin_gts[%d]: Genotype %d not supported.\n",i,bin_gts[i]);
					exit(1);
				}
			}
		
			// fprintf(stderr,"%d (%d,%d)\n",n_sim_reads,bin_gts[0],bin_gts[1]);
			// 
			a_ad=0;

			for (int i=0; i<n_sim_reads; i++){
				if(drand48()<0.5){
					gl_log10(pick_base(errate,bin_gts[0]), errate, like);
				}else{
					gl_log10(pick_base(errate,bin_gts[1]), errate, like);
				}
			}

#if 0
			fprintf(stderr, "\n");
			fprintf(stderr, "like(");
			for(int i=0;i<10;i++){
				if (i) {fprintf(stderr, ",");}
				fprintf(stderr, "%f",like[i]);
			}
			fprintf(stderr, ")");
			fprintf(stderr, "\n");
#endif
			rescale_likelihood_ratio(like);


			for(int j=0;j<10;j++){
				gl_vals[sample_i*10+j]=like[vcf_gl_order_idx[j]];
			}

			dp_vals[sample_i]=n_sim_reads;
			ad_vals[sample_i*2+0]=a_ad;
			ad_vals[sample_i*2+1]=n_sim_reads-a_ad;

		}

	} //end sample loop


	bcf_update_format_int32(out_hdr, out_bcf, "DP", dp_vals,nSamples);
	// add allele count column
	bcf_update_format_int32(out_hdr, out_bcf, "AD", ad_vals,2*nSamples);

	// update ref, alt
	if(bcf_update_alleles_str(out_hdr,out_bcf,"A,C,G,T")!=0){
		fprintf(stderr,"Error: Failed to update\n");
		exit(1);
	}


	bcf_update_format_float(out_hdr, out_bcf, "GL", gl_vals,10*nSamples);
	return 0;
}


int main(int argc, char **argv) {


	if(argc==1){
		fprintf(stderr,"\n");
		fprintf(stderr,"vcfgl\n\n");
		fprintf(stderr,"\tUsage: ./vcfgl -in <input> [options]\n\n");
		fprintf(stderr,"\t -in <input>\t\t\tinput\n");
		fprintf(stderr,"\n");
		fprintf(stderr,"Options:\n");
		fprintf(stderr,"\t-out <prefix>\t\t\toutput prefix\n");
		fprintf(stderr,"\t-O <mode>\t\t\toutput mode\n");
		fprintf(stderr,"\t-mode <mode>\t\t\toutput mode\n");
		fprintf(stderr,"\t-depth <depth>\t\t\tdepth\n");
		fprintf(stderr,"\t-df <depths_file>\t\t\tdepths file\n");
		fprintf(stderr,"\t-err <error_rate>\t\terror rate\n");
		fprintf(stderr,"\t-seed <seed>\t\t\tseed\n");
		fprintf(stderr,"\t-explode [0|1] <explode>\texplode\n");
		fprintf(stderr,"\t-pos0 [0|1] <pos0>\t\tpos0\n");

		return 0;
	}
	argStruct *args=args_get(--argc,++argv);

	if(args!=NULL){

		char *in_fn=args->in_fn;
		char *out_fp=args->out_fp;
		char* in_mps_depths=args->in_mps_depths;
		double *mps_depths=NULL;
		double errate=args->errate;
		double mps_depth=args->mps_depth;
		int pos0=args->pos0;

		FILE *arg_ff=openFile(out_fp,".arg");


		fprintf(stderr,"\n-in %s -out %s -err %f -depth %f -depths_file %s -pos0 %d -seed %d -mode %s -in_fa %s -explode %d\n",args->in_fn,args->out_fp,args->errate,args->mps_depth,args->in_mps_depths,args->pos0,args->seed,args->output_mode,args->in_fa,args->explode);
		fprintf(arg_ff,"\n-in %s -out %s -err %f -depth %f -depths_file %s -pos0 %d -seed %d -mode %s -in_fa %s -explode %d\n",args->in_fn,args->out_fp,args->errate,args->mps_depth,args->in_mps_depths,args->pos0,args->seed,args->output_mode,args->in_fa,args->explode);


		vcfFile * in_ff = bcf_open(in_fn, "r");
		vcfFile * out_ff;

		char *OUT_EXT;
		char *out_fn=NULL;
		switch (*args->output_mode){
			case 'v':
				fprintf(stderr,"\nOutput is VCF file\n");
				OUT_EXT=strdup(".vcf");
				out_fn = (char*)malloc(strlen(out_fp)+strlen(OUT_EXT)+1);
				strcpy(out_fn,out_fp);
				strcat(out_fn,OUT_EXT);
				out_ff = bcf_open(out_fn, "w");
				break;
			case 'b':
				fprintf(stderr,"\nOutput is BCF file\n");
				OUT_EXT=strdup(".bcf");
				out_fn = (char*)malloc(strlen(out_fp)+strlen(OUT_EXT)+1);
				strcpy(out_fn,out_fp);
				strcat(out_fn,OUT_EXT);
				out_ff = bcf_open(out_fn, "wb");
				break;
			case 'z':
				fprintf(stderr,"\nOutput is compressed VCF file\n");
				OUT_EXT=strdup(".vcf.gz");
				out_fn = (char*)malloc(strlen(out_fp)+strlen(OUT_EXT)+1);
				strcpy(out_fn,out_fp);
				strcat(out_fn,OUT_EXT);
				out_ff = bcf_open(out_fn, "wz");
				break;
			case 'u':
				fprintf(stderr,"\nOutput is uncompressed BCF file\n");
				OUT_EXT=strdup(".bcf");
				out_fn = (char*)malloc(strlen(out_fp)+strlen(OUT_EXT)+1);
				strcpy(out_fn,out_fp);
				strcat(out_fn,OUT_EXT);
				out_ff = bcf_open(out_fn, "wbu");
				break;
		}
		free(OUT_EXT);

		if (in_ff == NULL) {
			return 1;
		}

		if (bcf == 0) {
			return 1; 
		}



		bcf_hdr_t *hdr = bcf_hdr_read(in_ff);

		bcf_hdr_t *out_hdr = bcf_hdr_dup(hdr);
		bcf_hdr_merge(out_hdr,hdr);


		char *DATE_TAG;
		char *DATETIME=get_time();
		fprintf(stderr,"\n%s\n",DATETIME);

		if(asprintf(&DATE_TAG, "##fileDate=%s", DATETIME)>0){

			if(bcf_hdr_append(out_hdr, DATE_TAG)!=0){
				fprintf(stderr,"failed to append header\n");
				exit(1);
			}
			free(DATE_TAG);
		}else{
			exit(1);
		}
		char *SOURCE_TAG;
		if(asprintf(&SOURCE_TAG, "##source=vcfgl -err %f -depth %f -df %s -pos0 %d -seed %d -explode %d",args->errate,args->mps_depth,args->in_mps_depths, args->pos0,args->seed, args->explode)>0){

			if(bcf_hdr_append(out_hdr, SOURCE_TAG)!=0){
				fprintf(stderr,"failed to append header\n");
				exit(1);
			}
			free(SOURCE_TAG);
		}else{
			exit(1);
		}

		char *SOURCE_VERSION_TAG;
		if(asprintf(&SOURCE_VERSION_TAG, "##source=vcfgl version: %s",VCFGL_VERSION)>0){
			if(bcf_hdr_append(out_hdr, SOURCE_VERSION_TAG)!=0){
				fprintf(stderr,"failed to append header\n");
				exit(1);
			}
			free(SOURCE_VERSION_TAG);
		}else{
			exit(1);
		}


		if(bcf_hdr_append(out_hdr, "##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Simulated read depth\">")!=0){
			fprintf(stderr,"failed to append header\n");
			exit(1);
		}

		if(bcf_hdr_append(out_hdr, "##FORMAT=<ID=GL,Number=G,Type=Float,Description=\"Genotype likelihood in log10 likelihood ratio format\">")!=0){
			fprintf(stderr,"failed to append header\n");
			exit(1);
		}

		if(bcf_hdr_write(out_ff,out_hdr)!=0){
			fprintf(stderr,"failed to write bcf\n");
			exit(1);
		}

		bcf1_t *bcf = bcf_init();
		int nSites=0;



		if(pos0){
			fprintf(stderr, "\n -pos0=%d ; This means input VCF's positions are 0 based, and will shift coordinate system with +1\n", pos0);
		}

		int nSamples=bcf_hdr_nsamples(hdr);


		if(in_mps_depths!=NULL){
			mps_depths=read_depthsFile(in_mps_depths, nSamples);

			fprintf(stderr, "\n");
			for (int sample_i=0; sample_i<nSamples; sample_i++) {
				fprintf(stderr, "Individual %d mean per-site depth is set to %f\n", sample_i,mps_depths[sample_i]);
			}
		}


		fprintf(stderr, "\nReading file:\t\"%s\"\n", in_fn);
		fprintf(stderr, "Number of samples: %i\n", bcf_hdr_nsamples(hdr));
		fprintf(stderr,	"Number of contigs: %d\n",hdr->n[BCF_DT_CTG]);


		bcf1_t *out_bcf=bcf_init();
		bcf1_t *blank = bcf_init();;

		while (bcf_read(in_ff, hdr, bcf) == 0) {
			//copy next record with data into out_bcf
			out_bcf=bcf_copy(out_bcf,bcf);
			if(args->explode==0){
				setval(out_hdr,out_bcf,nSamples,errate,mps_depth,mps_depths);
				if(out_bcf->pos==-1){
					if(pos0==0){
						fprintf(stderr,"\n[ERROR]: Input file coordinates start from 0; but -pos0 is not set to 1. Please run again with -pos0 1.\n\n");
						exit(1);
					}
				}
				out_bcf->pos += pos0;
				if(bcf_write(out_ff, out_hdr, out_bcf)!=0){
					fprintf(stderr,"Error: Failed to write\n");
					exit(1);
				}
				nSites++;
			}else{
				//ensure that we have a empty blank record that we can modify
				// if(blank==NULL){
					// blank = bcf_dup(out_bcf);
					blank = bcf_copy(blank,out_bcf);
				// }

				if(out_bcf->pos==-1){
					if(pos0==0){
						fprintf(stderr,"\n[ERROR]: Input file coordinates start from 0; but -pos0 is not set to 1. Please run again with -pos0 1.\n\n");
						exit(1);
					}
				}

				while(1){//this block should run for every site with missing/nodata
					//  fprintf(stderr,"\t\t-> out_bcfpos: %d nSites: %d\n",out_bcf->pos,nSites);
					// if(nSites==out_bcf->pos){
					if(nSites==out_bcf->pos+pos0){
						// fprintf(stderr,"now breaking\n");
						break;
					}

					setblank(blank,out_bcf,hdr);
					setval(out_hdr,blank,nSamples,errate,mps_depth,mps_depths);
					blank->pos = nSites;
					// fprintf(stderr,"blank->pos: %d\n",blank->pos+pos0);
					if(bcf_write(out_ff, out_hdr, blank)!=0){
						fprintf(stderr,"Error: Failed to write\n");
						exit(1);
					}
					nSites++;

				}
				// fprintf(stderr,"After loop that fills in missing data will print out: %d\n",out_bcf->pos+pos0+1);
				setval(out_hdr,out_bcf,nSamples,errate,mps_depth,mps_depths);
				out_bcf->pos += pos0;
				if(bcf_write(out_ff, out_hdr, out_bcf)!=0){
					fprintf(stderr,"Error: Failed to write\n");
					exit(1);
				}
				nSites++;
			}
		}
		if(args->explode==1){
			//		fprintf(stderr,	"Number of contigs: %d\n",hdr->n[BCF_DT_CTG]);
			bcf_idpair_t *ctg = ctg = hdr->id[BCF_DT_CTG];
			int contigsize = ctg[out_bcf->rid].val->info[0];
			// fprintf(stderr,"contigsize: %d\n",contigsize);

			while(nSites<contigsize){
				setblank(blank,out_bcf,hdr);
				setval(out_hdr,blank,nSamples,errate,mps_depth,mps_depths);
				blank->pos = nSites;
				if(bcf_write(out_ff, out_hdr, blank)!=0){
					fprintf(stderr,"Error: Failed to write\n");
					exit(1);
				}
				nSites++;
			}
		}



		fprintf(stderr, "Total number of sites: %i\n", nSites);

		bcf_hdr_destroy(hdr);
		bcf_destroy(bcf);
		bcf_hdr_destroy(out_hdr);
		bcf_destroy(out_bcf);
		bcf_destroy(blank);

		int BCF_CLOSE;
		if ( (BCF_CLOSE=bcf_close(in_ff))){
			fprintf(stderr,"bcf_close(%s): non-zero status %d\n",in_fn,BCF_CLOSE);
			exit(BCF_CLOSE);
		}

		if ( (BCF_CLOSE=bcf_close(out_ff)) ){
			fprintf(stderr,"bcf_close(%s): non-zero status %d\n",out_fn,BCF_CLOSE);
			exit(BCF_CLOSE);
		}else{
			fprintf(stderr,"\nDumping output to file: %s\n\n",out_fn);
		}

		free(out_fn);
		free(args->in_fn);
		free(args->out_fp);
		free(args->output_mode);
		free(args);
		if(gl_vals!=NULL){
			free(gl_vals);
			free(dp_vals);
		}
		fclose(arg_ff);
		free(gt_arr);

	}

	return 0;

}
